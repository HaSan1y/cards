(()=>{"use strict";function e(e){const t=new Uint8Array(e);let o="";for(const e of t)o+=String.fromCharCode(e);return btoa(o).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function t(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),o=(4-t.length%4)%4,n=t.padEnd(t.length+o,"="),r=atob(n),i=new ArrayBuffer(r.length),a=new Uint8Array(i);for(let e=0;e<r.length;e++)a[e]=r.charCodeAt(e);return i}function o(){return n.stubThis(void 0!==globalThis?.PublicKeyCredential&&"function"==typeof globalThis.PublicKeyCredential)}const n={stubThis:e=>e};function r(e){const{id:o}=e;return{...e,id:t(o),transports:e.transports}}function i(e){return"localhost"===e||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class a extends Error{constructor({message:e,code:t,cause:o,name:n}){super(e,{cause:o}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=n??o.name,this.code=t}}const s=new class{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const e=new Error("Cancelling existing WebAuthn API call for new one");e.name="AbortError",this.controller.abort(e)}const e=new AbortController;return this.controller=e,e.signal}cancelCeremony(){if(this.controller){const e=new Error("Manually cancelling existing WebAuthn API call");e.name="AbortError",this.controller.abort(e),this.controller=void 0}}},l=["cross-platform","platform"];function c(e){if(e&&!(l.indexOf(e)<0))return e}function u(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.\n`,t)}const d=e=>e;console.log("Script loaded"),document.querySelector("[data-email]");const g=document.querySelector("[data-modal]"),h=document.querySelector("[data-close]"),m="https://db-2-cards.vercel.app"===window.location.origin?"https://db-2-cards.vercel.app/api/":"http://localhost:8888"===window.location.origin?"http://localhost:8888/.netlify/functions/N":"https://elegant-bubblegum-a62895.netlify.app"===window.location.origin?"https://elegant-bubblegum-a62895.netlify.app/.netlify/functions/N":"http://localhost:3000/api/";function p(e){if(g&&g.querySelector){const t=g.querySelector("[data-content]");t?t.innerText=e:console.error("Modal content element '[data-content]' not found."),"function"==typeof g.showModal?g.showModal():console.error("Modal element does not have a showModal method.")}else console.error("Modal element '[data-modal]' not found."),alert(e)}document.addEventListener("DOMContentLoaded",(function(){console.log("DOM fully loaded"),document.getElementById("authForm");const n=document.getElementById("formTitle"),l=document.getElementById("formDescription"),g=document.getElementById("emailGroup"),h=document.getElementById("submitButton"),f=document.getElementById("toggleMode"),w=document.getElementById("toggleLabel"),y=document.getElementById("errorMessage"),E=document.getElementById("successMessage");let b=!0;function R(){b?(n.textContent="Login",l.textContent="Welcome back! Please login to your account.",g.style.display="none",h.textContent="Login with Passkey",h.removeAttribute("data-signup"),h.setAttribute("data-login",""),w.textContent="Need an account?"):(n.textContent="Register",l.textContent="Create a new account to get started.",g.style.display="block",h.textContent="Register with Passkey",h.removeAttribute("data-login"),h.setAttribute("data-signup",""),w.textContent="Already have an account? Login"),y.textContent="",E.textContent="",h&&(h.disabled=!1)}R(),f.addEventListener("change",(function(){b=!b,R()})),h?h.addEventListener("click",(async n=>{n.preventDefault();const l=document.getElementById("username"),g=document.getElementById("email"),f=document.getElementById("password"),w=l.value.trim(),A=g?g.value.trim():"",I=f.value;if(y.textContent="",E.textContent="",w){if(!I||I.length<6)return console.log("Password validation failed"),void(y.textContent="Password is required and must be at least 6 characters long.");if(!b){if(!A)return void(y.textContent="Email is required for registration.");function v(e){return/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e)}if(!v(A))return void(y.textContent="Please enter a valid email address.")}console.log("Validation passed. Proceeding with",b?"Login":"Registration"),h.disabled=!0,h.textContent=b?"Logging in...":"Registering...";try{b?(console.log("Login attempt"),await async function(n,l){console.log("Login function called");const u=document.getElementById("errorMessage"),g=document.getElementById("successMessage");let h=null,f=null;try{const u=m;console.log(`Calling init-auth for user: ${n}`);const w=await fetch(`${u}init-auth`,{method:"POST",headers:{"Content-Type":"application/json",Accept:"application/json"},body:JSON.stringify({username:n,password:l}),credentials:"include"}),y=await w.json();if(console.log("initData:",y),!w.ok)throw new Error(y.error||`Authentication initialization failed (${w.status})`);if(!y.options||!y.challenge||!y.userId)throw console.error("Incomplete data received from init-auth:",y),new Error("Server did not provide necessary data to start passkey login.");const E=y.options;let b;console.log("Received options object:",JSON.stringify(E,null,2)),h=y.challenge,f=y.userId,console.log(`init-auth successful. Challenge: ${h}, UserID: ${f}`);try{b=await async function(n){!n.optionsJSON&&n.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),n={optionsJSON:n});const{optionsJSON:l,useBrowserAutofill:u=!1,verifyBrowserAutofillInput:g=!0}=n;if(!o())throw new Error("WebAuthn is not supported in this browser");let h;0!==l.allowCredentials?.length&&(h=l.allowCredentials?.map(r));const m={...l,challenge:t(l.challenge),allowCredentials:h},p={};if(u){if(!await function(){if(!o())return d(new Promise((e=>e(!1))));const e=globalThis.PublicKeyCredential;return d(void 0===e?.isConditionalMediationAvailable?new Promise((e=>e(!1))):e.isConditionalMediationAvailable())}())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&g)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');p.mediation="conditional",m.allowCredentials=[]}let f;p.publicKey=m,p.signal=s.createNewAbortSignal();try{f=await navigator.credentials.get(p)}catch(e){throw function({error:e,options:t}){const{publicKey:o}=t;if(!o)throw Error("options was missing required publicKey property");if("AbortError"===e.name){if(t.signal instanceof AbortSignal)return new a({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if("NotAllowedError"===e.name)return new a({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if("SecurityError"===e.name){const t=globalThis.location.hostname;if(!i(t))return new a({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e});if(o.rpId!==t)return new a({message:`The RP ID "${o.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else if("UnknownError"===e.name)return new a({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}({error:e,options:p})}if(!f)throw new Error("Authentication was not completed");const{id:w,rawId:y,response:E,type:b}=f;let R;return E.userHandle&&(R=e(E.userHandle)),{id:w,rawId:e(y),response:{authenticatorData:e(E.authenticatorData),clientDataJSON:e(E.clientDataJSON),signature:e(E.signature),userHandle:R},type:b,clientExtensionResults:f.getClientExtensionResults(),authenticatorAttachment:c(f.authenticatorAttachment)}}(E),console.log("startAuthentication successful:",b)}catch(e){if("NotAllowedError"===e.name)throw new Error("Passkey authentication cancelled.");throw console.error("startAuthentication error:",e),new Error("Failed to initiate passkey usage.")}const R={...b,expectedChallenge:h,userId:f};console.log("Calling verify-auth with body:",R);const A=await fetch(`${u}verify-auth`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(R),credentials:"include"}),I=await A.json();if(!A.ok)throw new Error(I.error||`Authentication verification failed (${A.status})`);if(!I.verified)throw new Error(I.error||"Login failed after verification.");{console.log("verify-auth successful.");const e=I.username||n;g.textContent=`Successfully logged in as ${e}!`,p(`Successfully logged in as ${e}!`),document.getElementById("username").value="",document.getElementById("password").value=""}}catch(e){console.error("Login error:",e),u.textContent=e.message||"An unknown login error occurred.",p(e.message||"An unknown login error occurred.")}}(w,I)):(console.log("Signup attempt"),await async function(n,l,d){console.log("Register function called");const g=document.getElementById("errorMessage"),h=document.getElementById("successMessage");let f,w,y=null;try{const g=m,E=await fetch(`${g}init-register?email=${encodeURIComponent(l)}`,{method:"GET",headers:{Accept:"application/json"},credentials:"include"}),b=await E.json();if(console.log("initData:",b),!E.ok)throw new Error(b.error||`Registration initialization failed (${E.status})`);if(!(b.options&&b.challenge&&b.userId&&b.email))throw console.error("Incomplete data received from init-register:",b),new Error("Server did not provide necessary data to start passkey registration.");const R=b.options;if(!R.user||"string"!=typeof R.user.name||""===R.user.name)throw console.error("CRITICAL (Client Check): options.user.name is missing or invalid in the object received from the server!",R.user),new Error("Server configuration error: User name missing in registration options. Please contact support or the administrator.");let A;console.log("Received options object:",JSON.stringify(R,null,2)),R.user?(console.log("Received options.user object:",JSON.stringify(R.user,null,2)),void 0===R.user.name?console.error("CRITICAL: options.user.name is UNDEFINED in the object received from the server!"):console.log("options.user.name value:",R.user.name)):console.error("CRITICAL: options.user is MISSING in the object received from the server!"),f=b.challenge,w=b.userId,y=b.email,console.log(`init-register successful. Challenge: ${f}, UserID: ${w}`),l!==y&&console.warn(`Email mismatch between form ('${l}') and init-register response ('${y}'). Using server response.`);try{A=await async function(n){!n.optionsJSON&&n.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),n={optionsJSON:n});const{optionsJSON:l,useAutoRegister:d=!1}=n;if(!o())throw new Error("WebAuthn is not supported in this browser");const g={...l,challenge:t(l.challenge),user:{...l.user,id:t(l.user.id)},excludeCredentials:l.excludeCredentials?.map(r)},h={};let m;d&&(h.mediation="conditional"),h.publicKey=g,h.signal=s.createNewAbortSignal();try{m=await navigator.credentials.create(h)}catch(e){throw function({error:e,options:t}){const{publicKey:o}=t;if(!o)throw Error("options was missing required publicKey property");if("AbortError"===e.name){if(t.signal instanceof AbortSignal)return new a({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if("ConstraintError"===e.name){if(!0===o.authenticatorSelection?.requireResidentKey)return new a({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if("conditional"===t.mediation&&"required"===o.authenticatorSelection?.userVerification)return new a({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if("required"===o.authenticatorSelection?.userVerification)return new a({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if("InvalidStateError"===e.name)return new a({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if("NotAllowedError"===e.name)return new a({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if("NotSupportedError"===e.name)return 0===o.pubKeyCredParams.filter((e=>"public-key"===e.type)).length?new a({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new a({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if("SecurityError"===e.name){const t=globalThis.location.hostname;if(!i(t))return new a({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e});if(o.rp.id!==t)return new a({message:`The RP ID "${o.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else if("TypeError"===e.name){if(o.user.id.byteLength<1||o.user.id.byteLength>64)return new a({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if("UnknownError"===e.name)return new a({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}({error:e,options:h})}if(!m)throw new Error("Registration was not completed");const{id:p,rawId:f,response:w,type:y}=m;let E,b,R,A;if("function"==typeof w.getTransports&&(E=w.getTransports()),"function"==typeof w.getPublicKeyAlgorithm)try{b=w.getPublicKeyAlgorithm()}catch(e){u("getPublicKeyAlgorithm()",e)}if("function"==typeof w.getPublicKey)try{const t=w.getPublicKey();null!==t&&(R=e(t))}catch(e){u("getPublicKey()",e)}if("function"==typeof w.getAuthenticatorData)try{A=e(w.getAuthenticatorData())}catch(e){u("getAuthenticatorData()",e)}return{id:p,rawId:e(f),response:{attestationObject:e(w.attestationObject),clientDataJSON:e(w.clientDataJSON),transports:E,publicKeyAlgorithm:b,publicKey:R,authenticatorData:A},type:y,clientExtensionResults:m.getClientExtensionResults(),authenticatorAttachment:c(m.authenticatorAttachment)}}(R),console.log("startRegistration successful:",A)}catch(e){if("InvalidStateError"===e.name||"NotAllowedError"===e.name)throw new Error("Passkey registration cancelled or not supported by browser/authenticator.");throw console.error("startRegistration error:",e),new Error("Failed to initiate passkey creation.")}const I={...A,username:n,email:y,password:d,expectedChallenge:f,userId:w};console.log("Calling verify-register with body:",I);const v=await fetch(`${g}verify-register`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(I),credentials:"include"}),C=await v.json();if(!v.ok)throw new Error(C.error||`Registration verification failed (${v.status})`);if(!C.verified)throw new Error(C.error||"Registration failed after verification.");console.log("verify-register successful."),h.textContent=`Successfully registered ${n}! You can now log in.`,p(`Successfully registered ${n}!`),document.getElementById("username").value="",document.getElementById("email").value="",document.getElementById("password").value=""}catch(e){throw console.error("Registration error:",e),g.textContent=e.message||"An unknown registration error occurred.",p(e.message||"An unknown registration error occurred."),e}}(w,A,I))}catch(C){console.error("Unhandled error during auth process:",C),y.textContent=C.message||"An unexpected error occurred."}finally{h&&(h.disabled=!1,R())}}else y.textContent="Username is required."})):console.error("Submit button element not found")})),h.addEventListener("click",(()=>g.close()))})();